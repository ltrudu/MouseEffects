// SpirographShader.hlsl - Beautiful spirograph patterns with mathematical curves

static const float PI = 3.14159265359;
static const float TAU = 6.28318530718;

// Constant buffer
cbuffer Constants : register(b0)
{
    float2 ViewportSize;
    float2 MousePosition;

    float Time;
    float InnerRadius;
    float OuterRadius;
    float PenOffset;

    float RotationSpeed;
    float LineThickness;
    float GlowIntensity;
    int NumPetals;

    float TrailFadeSpeed;
    float ColorCycleSpeed;
    int ColorMode;
    float HdrMultiplier;

    float4 PrimaryColor;
    float4 SecondaryColor;
    float4 TertiaryColor;

    float4 Padding;
}

struct VSOutput
{
    float4 Position : SV_POSITION;
    float2 TexCoord : TEXCOORD0;
};

// ============================================
// Spirograph Math
// ============================================

// Calculate spirograph point using parametric equations
// Hypotrochoid formula: point on curve generated by rolling circle inside another circle
float2 spirographPoint(float t, float R, float r, float d)
{
    float x = (R - r) * cos(t) + d * cos((R - r) / r * t);
    float y = (R - r) * sin(t) + d * sin((R - r) / r * t);
    return float2(x, y);
}

// ============================================
// Color Functions
// ============================================

// HSV to RGB conversion for rainbow colors
float3 hsv2rgb(float h, float s, float v)
{
    float c = v * s;
    float x = c * (1.0 - abs(fmod(h * 6.0, 2.0) - 1.0));
    float m = v - c;

    float3 rgb = float3(0, 0, 0);
    if (h < 0.166667) rgb = float3(c, x, 0);
    else if (h < 0.333333) rgb = float3(x, c, 0);
    else if (h < 0.5) rgb = float3(0, c, x);
    else if (h < 0.666667) rgb = float3(0, x, c);
    else if (h < 0.833333) rgb = float3(x, 0, c);
    else rgb = float3(c, 0, x);

    return rgb + m;
}

// Get color based on position along curve
float4 getCurveColor(float t, float curveProgress)
{
    if (ColorMode == 0) // Rainbow cycle
    {
        float hue = fmod((t / TAU + Time * ColorCycleSpeed * 0.1), 1.0);
        return float4(hsv2rgb(hue, 1.0, 1.0), 1.0);
    }
    else if (ColorMode == 1) // Fixed color
    {
        return PrimaryColor;
    }
    else // Gradient mode
    {
        // Blend between three colors based on position
        float t1 = smoothstep(0.0, 0.5, curveProgress);
        float t2 = smoothstep(0.5, 1.0, curveProgress);
        float4 color1 = lerp(PrimaryColor, SecondaryColor, t1);
        return lerp(color1, TertiaryColor, t2);
    }
}

// ============================================
// Distance Functions
// ============================================

// Distance from point to spirograph curve
float distanceToSpirograph(float2 p, float2 center)
{
    float minDist = 1000000.0;

    // Sample the curve to find closest point
    float R = OuterRadius;
    float r = InnerRadius;
    float d = PenOffset;

    // Animated angle based on time
    float angleOffset = Time * RotationSpeed;

    // Sample curve with enough detail
    int samples = max(64, NumPetals * 8);
    float maxT = TAU * float(NumPetals);

    for (int i = 0; i < samples; i++)
    {
        float t = (float(i) / float(samples)) * maxT + angleOffset;
        float2 curvePoint = spirographPoint(t, R, r, d) + center;

        float dist = length(p - curvePoint);
        minDist = min(minDist, dist);
    }

    return minDist;
}

// Distance with trail fade effect
float distanceToSpirographWithFade(float2 p, float2 center)
{
    float minDist = 1000000.0;
    float closestT = 0.0;

    float R = OuterRadius;
    float r = InnerRadius;
    float d = PenOffset;

    float angleOffset = Time * RotationSpeed;
    int samples = max(64, NumPetals * 8);
    float maxT = TAU * float(NumPetals);

    // Find closest point and its parameter
    for (int i = 0; i < samples; i++)
    {
        float t = (float(i) / float(samples)) * maxT + angleOffset;
        float2 curvePoint = spirographPoint(t, R, r, d) + center;

        float dist = length(p - curvePoint);
        if (dist < minDist)
        {
            minDist = dist;
            closestT = t;
        }
    }

    return minDist;
}

// ============================================
// Vertex Shader
// ============================================

VSOutput VSMain(uint vertexId : SV_VertexID)
{
    VSOutput output;

    // Fullscreen triangle
    float2 uv = float2((vertexId << 1) & 2, vertexId & 2);
    output.Position = float4(uv * 2.0 - 1.0, 0.0, 1.0);
    output.Position.y = -output.Position.y;
    output.TexCoord = uv;

    return output;
}

// ============================================
// Pixel Shader
// ============================================

float4 PSMain(VSOutput input) : SV_TARGET
{
    float2 pixelPos = input.TexCoord * ViewportSize;
    float2 relativePos = pixelPos - MousePosition;

    // Calculate distance to spirograph curve
    float dist = distanceToSpirograph(pixelPos, MousePosition);

    // Line rendering with anti-aliasing
    float halfThickness = LineThickness * 0.5;
    float edge = 1.0 - smoothstep(halfThickness - 1.0, halfThickness + 1.0, dist);

    // Glow effect
    float glowRadius = LineThickness + 10.0 * GlowIntensity;
    float glow = exp(-dist * dist / (glowRadius * glowRadius)) * GlowIntensity;

    // Combine edge and glow
    float intensity = edge + glow;

    if (intensity < 0.01)
        discard;

    // Calculate color based on closest point on curve
    float R = OuterRadius;
    float r = InnerRadius;
    float d = PenOffset;
    float angleOffset = Time * RotationSpeed;

    // Find parameter t for closest point (simplified - use angle to mouse)
    float angle = atan2(relativePos.y, relativePos.x);
    float curveT = angle + angleOffset;
    float curveProgress = fmod(curveT / TAU, 1.0);

    // Get color
    float4 color = getCurveColor(curveT, curveProgress);

    // Apply intensity
    color.rgb *= intensity;
    color.a = saturate(intensity);

    // Apply HDR boost for brighter displays
    if (HdrMultiplier > 1.0)
    {
        float brightness = dot(color.rgb, float3(0.299, 0.587, 0.114));
        float hdrBoost = 1.0 + brightness * (HdrMultiplier - 1.0) * 0.5;
        color.rgb *= hdrBoost;
    }

    // Trail fade effect - fade older parts of the curve
    float fadeTime = fmod(Time * TrailFadeSpeed, TAU);
    float angleDiff = abs(curveT - fadeTime);
    angleDiff = min(angleDiff, TAU - angleDiff);
    float fadeFactor = 1.0 - saturate(angleDiff / (TAU * 0.5));
    color.a *= 0.5 + 0.5 * fadeFactor;

    return color;
}
